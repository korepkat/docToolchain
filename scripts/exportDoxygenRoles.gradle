//tag::exportDoxygenRoles[]

def parseNamespace(xmlFile, xml_dir, img_dir, img_type)
{
    def xml = new XmlSlurper().parse(xmlFile)
    def output = ""
    if (xml.compounddef.innerclass.size() > 0)
    {
       output += "== Namespace: " + xml.compounddef.compoundname + "\n\n"
    }

    def len = xml.compounddef.compoundname.toString().length()
    for ( cls in xml.compounddef.innerclass)
    {
        output += "[["+cls.@'refid'.toString()+"]]\n=== Class: " + cls.toString().substring(len+2) + "\n\n"
        def f = cls.@'refid'.toString()
        output += parseClass(xml_dir + f + ".xml", xml_dir, img_dir, img_type)
    }

    for ( nmsp in xml.compounddef.innernamespace)
    {
        output += parseNamespace(xml_dir + nmsp.@'refid' + ".xml", xml_dir, img_dir, img_type)
    }

    return output
}

def parseClass (xmlFile, xml_dir, img_dir, img_type)
{
    def xml = new XmlSlurper().parse(xmlFile)
    def output = ""
    
    def file = img_dir + xml.compounddef.@'id' + "__inherit__graph." + img_type;
    if(new File(file).exists())
    {
        output = "==== Inheritance diagram\n\n"
        output += "image::" + file + "[]\n\n"
    }

    file = img_dir + xml.compounddef.@'id' + "__coll__graph." + img_type;
    if(new File(file).exists())
    {
        output += "==== Collaboration diagram\n\n"
        output += "image::" + file + "[]\n\n"
    }

    def outClasses = "" 
    for ( section in xml.compounddef.sectiondef)
    {
        def type = 0
        
        switch(section.@'kind')
        {
            // Attributes
            case 'private-attrib':  output += "==== Private Attributes \n\n"
                                    type = 1
            break;
            case 'public-attrib':  output += "==== Public Attributes \n\n"
                                    type = 1
            break;
            case 'public-static-attrib': output += "==== Static Public Attributes \n\n"
                                    type = 1
            break;
            case 'private-static-attrib': output += "==== Static Private Attributes \n\n"
                                    type = 1
            break;
            case 'package-static-attrib': output += "==== Static Package Attributes \n\n"
                                    type = 1
            case 'package-attrib': output += "==== Package Attributes \n\n"
                                    type = 1
            break;
            // Functions
            case 'private-func':  output += "==== Private Functions \n\n"
                                    type = 2
            break;
            case 'public-func':  output += "==== Public Functions \n\n"
                                    type = 2
            break;
            case 'public-static-func':  output += "==== Static Public Functions \n\n"
                                    type = 2
            break;
            case 'private-static-func':  output += "==== Static Private Functions \n\n"
                                    type = 2
            break;
            case 'package-func':  output += "==== Package Functions \n\n"
                                    type = 2
            break;
            case 'package-static-func':  output += "==== Static Package Functions \n\n"
                                    type = 2
            break;
            case 'protected-func':  output += "==== Protected Functions \n\n"
                                    type = 2
            break;
            // Types
            case 'protected-type':  output += "==== Protected Types \n\n"
                                    type = 3
            break;
            case 'public-type':  output += "==== Public Types \n\n"
                                    type = 3
            break;
            // default
            default: println(section.@'kind')
        }
        
        if (type > 0 )
        {
            if(section.memberdef.size() > 0)
            {
                output += "[cols=\"1,3\"]\n|====\n\n"
                for (attr in section.memberdef)
                {
                    def isDesc = type==2?true:false
                    
                    if(isDesc)
                    {
                        outClasses += "[["+attr.@'id'+"]]\n"+"==== "+attr.name+"\n\n"
                        outClasses += "[source,java]\n----\n"
                        outClasses += attr.name.toString()+" "+attr.argsstring+"\n"
                        outClasses += "----\n\n"
                        outClasses += attr.briefdescription+"\n\n"
                        if (attr.param.size() > 0)
                        {
                            def paramMap = [:]
                            for(paramItem in attr.detaileddescription.para.parameterlist.parameteritem)
                            {
                                paramMap[paramItem.parameternamelist.parametername.toString()] = paramItem.parameterdescription.para.toString()
                            }

                            outClasses += "\n\n===== Parameter:\n[cols=\"1,1,2\",grid=\"none\"]\n|====\n\n"
                            for( param in attr.param)
                            {
                                outClasses += "| "
                                if (param.type.ref.size() == 1)
                                    outClasses += "xref:#"+param.type.ref.@'refid'+"["+param.type.ref+"]\n"
                                else
                                    outClasses += param.type+"\n"
                                outClasses += "| "+ param.declname + "\n"
                                outClasses += "| " + (paramMap.containsKey(param.declname)? paramMap[param.declname]:"" ) + "\n\n"
                            }
                            outClasses += "|====\n\n"
                        }

                        file = img_dir + attr.@'id' + "_cgraph." + img_type;
                        def index = file.lastIndexOf('_1') +1
                        file = file.substring(0,index)  + file.substring(index+1)
                        if(new File(file).exists())
                        {
                            outClasses += "===== Call Graph\n\n"
                            outClasses += "image::" + file + "[]\n\n"
                        }
                    }
                    output += "| " + attr.type.toString() + "\n"
                    output += "| "
                    if(isDesc)
                        output += "xref:#"+attr.@'id'+"[" + attr.name +"] "
                    else
                        output += attr.name +" "
                    output += attr.argsstring.toString() + attr.initializer.toString() + "\n\n"
                }
                output += "|====\n\n"
            }
        }
        
    }

    return output + outClasses
}

task exportDoxygenRoles(
        description: 'exports description and documentation from doxygen output',
        group: 'docToolchain'
) {
    doFirst {
        new File(targetDir).mkdirs()
    }
    doLast {
        logger.info("docToolchain> docDir: "+docDir)
        logger.info("docToolchain> mainConfigFile: "+mainConfigFile)
        def config = new ConfigSlurper().parse(new File(docDir, mainConfigFile).text)

        def output = "= API \n\n"
        config.doxygen.xml_dir = targetDir + "/" + config.doxygen.xml_dir
        config.doxygen.img_dir = targetDir + "/" + config.doxygen.img_dir
        for (namespace in config.doxygen.namespaces)
        {
            output += parseNamespace(config.doxygen.xml_dir + "namespace" + namespace + ".xml", config.doxygen.xml_dir, config.doxygen.img_dir, config.doxygen.img_type)
        }

        def apiFile = new File(targetDir, 'api.adoc')
        logger.info "> changelog exported ${apiFile.canonicalPath}"
        apiFile.write(output)
    }
}
//end::exportDoxygenRoles[]
