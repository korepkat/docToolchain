//tag::exportChangeLog[]

def parseGitLog(gitLog) {

    def version = 'Current'
    def categories = ["Bugfix","Added", "Changed", "Features","Deprecated",
    "Removed"]
    def category = ''
    def run = false
    def log = [:]


    gitLog.eachLine { line ->

        // skip empty lines
        if (line.trim() == "" )
            return
        // get Version
        def matcher = line =~ /commit .* \(.*tag: ([^,\)]*).*/
        matcher.find()
        if (matcher.size() == 1){
            version = matcher[0][1]
            return
        }

        // get Category
        matcher = line =~ / *(${categories.join("|")}):/
        if (matcher.size() == 1){
            category = matcher[0][1]
            return
        }

        // stop changelog on next commit
        if (line ==~ /commit.*/) {
            run = false
            return
        }

        // start changelog on keyword
        if (line ==~ / *changelog:/)
        {
            run = true
            category = ''
            return
        }

        // get changelog
        if (run) {
            if ( !log.containsKey(version) )
                log[version] = [:]
            if ( !log[version].containsKey(category))
                log[version][category] = []

            log[version][category].add(line.trim())
        }
    }

    def output = "= Changelog\n\n"
    for ( v in log ) {
        output += "\n\n== " + v.key + "\n\n"

        if (v.value.containsKey(""))
            output += v.value[""].join("\n")
        for ( c in categories){
            if (!v.value.containsKey(c))
                continue
            def entry = v.value[c]
            output += "\n\n=== " + c + ":\n\n"
            output += entry.join("\n")
        }
    }

    return output
}

def parseGitLogTag(gitLog) {

    def version = 'Current'
    def output = "= Changelog\n\n"
    def versionSet = false

    gitLog.eachLine { line ->
        // get Version
        if (!line.startsWith(' ')){
            version = line.substring(0, line.indexOf(' '));
            versionSet = false
            return
        }
        // get changelog
        if (!versionSet) { 
            output += "\n\n== "+ version + "\n\n"
            versionSet = true
        }
        output += line.trim() + "\n"
    }
    return output
}

task exportChangeLog(
        description: 'exports the change log from a git subpath',
        group: 'docToolchain'
) {
    doFirst {
        new File(targetDir).mkdirs()
    }
    doLast {
        logger.info("docToolchain> docDir: "+docDir)
        logger.info("docToolchain> mainConfigFile: "+mainConfigFile)
        def config = new ConfigSlurper().parse(new File(docDir, mainConfigFile).text)

        def cmd = "${config.changelog.cmd}"
        def changes = cmd.execute(null, new File(docDir, config.changelog.dir)).text
        if (config.changelog.parse.size() > 0)
        switch(config.changelog.parse)
        {
            case 'commit': changes = parseGitLog(changes)
            break
            case 'tag': changes = parseGitLogTag(changes)
            break
        }
        
        def changelog = new File(targetDir, 'changelog.adoc')
        logger.info "> changelog exported ${changelog.canonicalPath}"
        changelog.write(changes)
    }
}
//end::exportChangeLog[]
